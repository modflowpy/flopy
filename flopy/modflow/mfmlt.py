"""
mfzon module.  Contains the ModflowDrn class. Note that the user can access
the ModflowDrn class as `flopy.modflow.ModflowDrn`.

Additional information for this MODFLOW package can be found at the `Online
MODFLOW Guide
<http://water.usgs.gov/ogw/modflow/MODFLOW-2005-Guide/index.html?drn.htm>`_.

"""
import sys
import collections
import numpy as np
from flopy.mbase import Package
from flopy.utils import util_2d

class ModflowMlt(Package):
    """
    MODFLOW Multiplier Package Class.

    Parameters
    ----------
    model : model object
        The model object (of type :class:`flopy.modflow.mf.Modflow`) to which
        this package will be added.
    idrncb : int
        is a flag and a unit number. (the default is 0).
    layer_row_column_data : list of records
        In its most general form, this is a triple list of drain records  The
        innermost list is the layer, row, column, elevation and conductance for
        a single drain.  Then for a stress period, there can be a list of
        drains.  Then for a simulation, there can be a separate list for each
        stress period. This gives the form of
            lrcd = [
                     [  #stress period 1
                       [l1, r1, c1, elev1, cond1],
                       [l2, r2, c2, elev2, cond2],
                       [l3, r3, c3, elev3, cond3],
                       ],
                     [  #stress period 2
                       [l1, r1, c1, elev1, cond1],
                       [l2, r2, c2, elev2, cond2],
                       [l3, r3, c3, elev3, cond3],
                       ], ...
                     [  #stress period kper
                       [l1, r1, c1, elev1, cond1],
                       [l2, r2, c2, elev2, cond2],
                       [l3, r3, c3, elev3, cond3],
                       ],
                    ]
        Note that if there are not records in layer_row_column_data, then the
        last group of drains will apply until the end of the simulation.
    layer_row_column_elevation_cond : list of records
        Deprecated - use layer_row_column_data instead.
    options : list of strings
        Package options. (default is None).
    naux : int
        number of auxiliary variables
    extension : string
        Filename extension (default is 'drn')
    unitnumber : int
        File unit number (default is 21).
    zerobase : boolean (default is True)
        True when zero-based indices are used: layers, rows, columns start at 0
        False when one-based indices are used: layers, rows, columns start at 1 (deprecated)


    Attributes
    ----------
    mxactd : int
        Maximum number of drains for a stress period.  This is calculated
        automatically by FloPy based on the information in
        layer_row_column_data.

    Methods
    -------

    See Also
    --------

    Notes
    -----
    Parameters are not supported in FloPy.

    Examples
    --------

    >>> import flopy
    >>> m = flopy.modflow.Modflow()
    >>> lrcd = [[[2, 3, 4, 10., 100.]]]  #this drain will be applied to all
    >>>                                  #stress periods
    >>> drn = flopy.modflow.ModflowDrn(m, layer_row_column_data=lrcd)

    """
    def __init__(self, model, mult_dict=None,
                 extension ='mlt', unitnumber=1002):
        Package.__init__(self, model, extension, 'MULT', unitnumber) # Call ancestor's init to set self.parent, extension, name and unit number
        self.heading = '# MULT for MODFLOW, generated by Flopy.\n# Really...why do you want to use this'
        self.url = 'zon.htm'

        self.nml = 0
        if mult_dict is not None:
          self.nml = len(mult_dict)
          self.mult_dict = mult_dict
          print mult_dict
        self.parent.add_package(self)

    def write_file(self):
        f = open(self.fn_path, 'w')
        f.write('%s\n' % self.heading)

        line = '{0:10d}\n'.format(self.nml)
        f.write(line)
        
        if self.nml > 0:
            for key, value in self.mult_dict.iteritems():
                f.write('{}'.format(key))
                if isinstance(value,util_2d):
                    f.write(value.get_file_entry())
                else:
                    f.write('{}\n{}\n'.format(value[0], value[1]))
        f.close()

    @staticmethod
    def load(f, model, nrow=None, ncol=None, ext_unit_dict=None):
        '''
        f is either a filename or a file handle.  if the arrays in the file
        are specified using interal, external, or older style array control
        records, then f should be a file handle, and the ext_unit_dict
        dictionary of unitnumber:open(filename, 'r') must be included.
        '''
        if type(f) is not file:
            filename = f
            f = open(filename, 'r')
        #dataset 0 -- header
        while True:
            line = f.readline()
            if line[0] != '#':
                break
        #dataset 1
        t = line.strip().split()
        nml = int(t[0])

        #get nlay,nrow,ncol if not passed
        if nrow is None and ncol is None:
            nrow, ncol, nlay, nper = model.get_nrow_ncol_nlay_nper()

        #read zone data
        mult_dict = collections.OrderedDict()
        for n in xrange(nml):
            line = f.readline()
            t = line.strip().split()
            if len(t[0]) > 10:
                mltnam = t[0][0:10].lower()
            else:
                mltnam = t[0].lower()
            sys.stdout.write('reading data for "{:<10s}" mult\n'.format(mltnam))
            readArray = True
            kwrd = None
            if len(t) > 1:
                if 'function' in t[1].lower() or 'expression' in t[1].lower():
                    readArray = False
                    kwrd = t[1].lower()
            #--load data
            if readArray:
                t = util_2d.load(f, model, (nrow,ncol), np.float32, mltnam,
                                 ext_unit_dict)
            else:
                line = f.readline()
                t = [kwrd, line]
            mult_dict[mltnam] = t
        mlt = ModflowMlt(model, mult_dict=mult_dict)
        return mlt
