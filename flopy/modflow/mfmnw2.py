# from numpy import empty, zeros, ones, where
import numpy as np
from flopy.mbase import Package


class ModflowMnw2(Package):
    'Multi-node well 2 package class'
    '''
    NOTE: This implementation does not allow well loss parameters {Rw,Rskin,Kskin,B,C,P,CWC,PP} to vary along the length of a given well. It also
    does not currently support data sections 2e, 2f, 2g, 2h, or 4b as defined in the data input instructions for the MNW2 package.    
    '''

    def __init__(self, model, mnwmax=0, iwl2cb=-1, mnwprnt=0, aux=None,
                 wellid=None, nnodes=None, losstype=None, pumploc=0, qlimit=0, ppflag=0, pumpcap=0,
                 lay_row_col=None, ztop_zbotm_row_col=None, rw=0, rskin=0, kskin=0, b=0, c=0, p=0, cwc=0, pp=1,
                 itmp=0,wellid_qdes=None,
                 extension='mnw2', unitnumber=34):
        """
        Package constructor
        """
        Package.__init__(self, model, extension, 'MNW2',
                         unitnumber)  # Call ancestor's init to set self.parent, extension, name, and unit number

        self.url = 'mnw2.htm'
        self.nper = self.parent.nrow_ncol_nlay_nper[-1]
        self.heading = '# Multi-node well 2 (MNW2) file for MODFLOW, generated by Flopy'
        self.mnwmax = int(mnwmax)  # -maximum number of multi-node wells to be simulated
        self.iwl2cb = int(iwl2cb)  # -flag and unit number
        self.mnwprnt = int(mnwprnt)  # -verbosity flag
        self.aux = aux  # -list of optional auxilary parameters
        self.wellid = wellid  # -array containing well id's (shape = (MNWMAX))

        self.lay_row_col = lay_row_col  # -list of arrays containing lay, row, and col for all well nodes [NNODES > 0](shape = (NNODES,3), length = MNWMAX)
        self.ztop_zbotm_row_col = ztop_zbotm_row_col  # -list of arrays containing top and botm elevation of all open intervals [NNODES < 0](shape = (abs(NNODES),2), length = MNWMAX)

        self.wellid_qdes = wellid_qdes  #-list of arrays containing desired Q for each well in each stress period (shape = (NPER,MNWMAX,2))

        #-create empty arrays of the correct size
        '''
        NOTE: some arrays are not pre-formatted here as their shapes vary from well to well and from period to period.
        '''
        self.wellid = np.empty((self.mnwmax), dtype='S25')
        self.nnodes = np.zeros((self.mnwmax), dtype=np.int32)
        self.losstype = np.empty((self.mnwmax), dtype='S25')
        self.pumploc = np.zeros((self.mnwmax), dtype='int32')
        self.qlimit = np.zeros((self.mnwmax), dtype='int32')
        self.ppflag = np.zeros((self.mnwmax), dtype='int32')
        self.pumpcap = np.zeros((self.mnwmax), dtype='int32')
        self.rw = np.zeros(self.mnwmax, dtype='float32')
        self.rskin = np.zeros(self.mnwmax, dtype='float32')
        self.kskin = np.zeros(self.mnwmax, dtype='float32')
        self.b = np.zeros(self.mnwmax, dtype='float32')
        self.c = np.zeros(self.mnwmax, dtype='float32')
        self.p = np.zeros(self.mnwmax, dtype='float32')
        self.cwc = np.zeros(self.mnwmax, dtype='float32')
        self.pp = np.zeros(self.mnwmax, dtype='float32')

        self.itmp = np.zeros(self.nper, dtype='int32')

        #-assign values to arrays        
        self.wellid[:] = np.array(wellid, dtype='S25')
        self.nnodes[:] = np.array(nnodes, dtype=np.int)
        self.losstype[:] = np.array(losstype, dtype='S25')
        self.pumploc[:] = np.array(pumploc, dtype=np.int32)
        self.qlimit[:] = np.array(qlimit, dtype=np.int32)
        self.ppflag[:] = np.array(ppflag, dtype=np.int32)
        self.pumpcap[:] = np.array(pumpcap, dtype=np.int32)
        self.rw[:] = np.array(rw, dtype=np.float32)
        self.rskin[:] = np.array(rskin, dtype=np.float32)
        self.kskin[:] = np.array(kskin, dtype=np.float32)
        self.b[:] = np.array(b, dtype=np.float32)
        self.c[:] = np.array(c, dtype=np.float32)
        self.p[:] = np.array(p, dtype=np.float32)
        self.cwc[:] = np.array(cwc, dtype=np.float32)
        self.pp[:] = np.array(pp, dtype=np.float32)

        self.itmp[:] = np.array(itmp, dtype=np.int32)

        #-input format checks:
        lossTypes = ['NONE', 'THIEM', 'SKIN', 'GENERAL', 'SPECIFYcwc']
        for i in range(mnwmax):
            assert len(self.wellid[i].split(' ')) == 1, 'WELLID (%s) must not contain spaces' % self.wellid[i]
            assert self.losstype[
                       i] in lossTypes, 'LOSSTYPE (%s) must be one of the following: NONE, THIEM, SKIN, GENERAL, or SPECIFYcwc' % \
                                        self.losstype[i]
        assert self.itmp[0] >= 0, 'ITMP must be greater than or equal to zero for the first time step.'
        assert self.itmp.max() <= self.mnwmax, 'ITMP cannot exceed maximum number of wells to be simulated.'

        self.parent.add_package(self)

    def write_file(self):
        """
        Write the file.

        """
        # -open file for writing
        f = open(self.fn_path, 'w')

        # -write header
        f.write('{}\n'.format(self.heading))

        # -Section 1 - MNWMAX, IWL2CB, MNWPRNT {OPTION}
        auxParamString = ''
        if self.aux != None:
            for param in self.aux:
                auxParamString = auxParamString + 'AUX %s ' % param
        f.write('{:10d}{:10d}{:10d} {}\n'.format(self.mnwmax,
                                                 self.iwl2cb,
                                                 self.mnwprnt,
                                                 auxParamString))

        # -Section 2 - Repeat this section MNWMAX times (once for each well)
        for i in xrange(self.mnwmax):
            #-Section 2a - WELLID, NNODES
            f.write('{}{:10d}\n'.format(self.wellid[i], self.nnodes[i]))
            #-Section 2b - LOSSTYPE, PUMPLOC, Qlimit, PPFLAG, PUMPCAP
            f.write('{} {:10d}{:10d}{:10d}{:10d}\n'.format(self.losstype[i],
                                                           self.pumploc[i],
                                                           self.qlimit[i],
                                                           self.ppflag[i],
                                                           self.pumpcap[i]))
            #-Section 2c - {Rw, Rskin, Kskin, B, C, P, CWC}
            if self.losstype[i] == 'THIEM':
                f.write('{:10.4g}\n'.format(self.rw[i]))
            elif self.losstype[i] == 'SKIN':
                f.write('{:10.4g}{:10.4g}{:10.4g}\n'.format(self.rw[i],
                                                            self.rskin[i],
                                                            self.kskin[i]))
            elif self.losstype[i] == 'GENERAL':
                f.write('{:10.4g}{:10.4g}{:10.4g}{:10.4g}\n'.format(self.rw[i],
                                                                    self.b[i],
                                                                    self.c[i],
                                                                    self.p[i]))
            elif self.losstype[i] == 'SPECIFYcwc':
                f.write('{:10.4g}\n'.format(self.cwc[i]))

            #-Section 2d - Repeat sections 2d-1 or 2d-2 once for each open interval
            #-Section 2d-1 - NNODES > 0; LAY, ROW, COL {Rw, Rskin, Kskin, B, C, P, CWC, PP}
            absNnodes = abs(self.nnodes[i])
            if self.nnodes[i] > 0:
                for n in xrange(absNnodes):
                    f.write('{:10d}{:10d}{:10d}\n'.format(self.lay_row_col[i][n, 0]+1,
                                                          self.lay_row_col[i][n, 1]+1,
                                                          self.lay_row_col[i][n, 2]+1))
            #-Section 2d-2 - NNODES < 0; Ztop, Zbotm, ROW, COL {Rw, Rskin, Kskin, B, C, P, CWC, PP}
            elif self.nnodes[i] < 0:
                for n in xrange(absNnodes):
                    #print i, n
                    #print self.ztop_zbotm_row_col
                    f.write('{:10.4g} {:10.4g} {:10d} {:10d}\n'.format(self.ztop_zbotm_row_col[i][n, 0],
                                                                       self.ztop_zbotm_row_col[i][n, 1],
                                                                       int(self.ztop_zbotm_row_col[i][n, 2])+1,
                                                                       int(self.ztop_zbotm_row_col[i][n, 3])+1))

        #-Section 3 - Repeat this section NPER times (once for each stress period)
        for p in range(self.nper):
            f.write('{:10d}\n'.format(self.itmp[p]))

            #-Section 4 - Repeat this section ITMP times (once for each well to be simulated in current stress period)
            if self.itmp[p] > 0:
                '''
                Create an array that will hold well names to be simulated during this stress period and find their corresponding
                index number in the "wellid" array so the right parameters (Hlim Qcut {Qfrcmn Qfrcmx}) are accessed.
                '''
                itmp_wellid_index_array = np.empty((self.itmp[p], 2), dtype='object')
                for well in xrange(self.itmp[p]):
                    itmp_wellid_index_array[well, 0] = self.wellid_qdes[p][well, 0]
                    itmp_wellid_index_array[well, 1] = np.where(self.wellid == self.wellid_qdes[p][well, 0])

                for j in xrange(self.itmp[p]):
                    #-Section 4a - WELLID Qdes {CapMult} {Cprime} {xyz}
                    assert self.wellid_qdes[p][j, 0] in self.wellid, \
                        'WELLID for pumping well is not present in "wellid" array'

                    #print self.wellid_qdes[p][j, 0], self.wellid_qdes[p][j, 1]

                    f.write('{} {:10.4g}\n'.format(self.wellid_qdes[p][j, 0],
                                                   float(self.wellid_qdes[p][j, 1])))

        f.close()

