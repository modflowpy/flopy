"""
mpsim module.  Contains the ModpathSim class. Note that the user can access
the ModpathSim class as `flopy.modpath.ModpathSim`.

Additional information for this MODFLOW/MODPATH package can be found at the
`Online MODFLOW Guide
<http://water.usgs.gov/ogw/modflow/MODFLOW-2005-Guide/index.html?dis.htm>`_.

"""
from enum import Enum
import numpy as np
from ..pakbase import Package
from ..utils import Util2d, Util3d, check
from .mp7particle import Particles
class simType(Enum):
    """
    Enumeration of different simulation types
    """
    endpoint = 1
    pathline = 2
    timeseries = 3
    combined = 4

class trackDir(Enum):
    """
    Enumeration of different tracking directions
    """
    forward = 1
    backward = 2

class weakOpt(Enum):
    """
    Enumeration of different weak sink and source options
    """
    pass_through = 1
    stop_at = 2

class budgetOpt(Enum):
    """
    Enumeration of different budget output options
    """
    no = 0
    summary = 1
    record_summary = 2

class stopOpt(Enum):
    """
    Enumeration of different stop time options
    """
    total = 1
    extend = 2
    specified = 3

class onoffOpt(Enum):
    """
    Enumeration of on-off options
    """
    off = 1
    on = 2


class Modpath7Sim(Package):
    """
    MODPATH Simulation File Package Class.

    Parameters
    ----------
    model : model object
        The model object (of type :class:`flopy.modpath.mp.Modpath`) to which
        this package will be added.
    extension : string
        Filename extension (default is 'mpsim')


    Attributes
    ----------
    heading : str
        Text string written to top of package input file.

    Methods
    -------

    See Also
    --------

    Notes
    -----

    Examples
    --------

    >>> import flopy
    >>> m = flopy.modpath.Modpath()
    >>> dis = flopy.modpath.ModpathSim(m)

    """

    def __init__(self, model, mp_name_file=None, listingfilename=None,
                 endpointfilename=None, pathlinefilename=None,
                 timeseriesfilename=None, tracefilename=None,
                 simulationtype='pathline', trackingdirection='forward',
                 weaksinkoption='stop_at', weaksourceoption='stop_at',
                 budgetoutputoption='no',
                 traceparticledata=None,
                 budgetcellnumbers=None, referencetime=None,
                 stoptimeoption='extend', StopTime=None,
                 timepointdata=None,
                 zonedataoption='off', stopzone=None, zones=None,
                 retardationfactoroption='off', retardation=None,
                 particlegroups=None,
                 extension='mpsim', unitnumber=None):

        if unitnumber is None:
            unitnumber = model.next_unit()


        # Call ancestor's init to set self.parent, extension, name and unit number
        Package.__init__(self, model, extension, 'MPSIM', unitnumber)

        self.heading = '# {} package for'.format(self.name[0]) + \
                       ' {}, '.format(model.version_types[model.version]) + \
                       'generated by Flopy.'

        # set file names
        if mp_name_file is None:
            mp_name_file = '{}.{}'.format(model.name, 'mpnam')
        self.mp_name_file = mp_name_file
        if listingfilename is None:
            listingfilename = '{}.{}'.format(model.name, 'mplst')
        self.listingfilename = listingfilename
        if endpointfilename is None:
            endpointfilename = '{}.{}'.format(model.name, 'mpend')
        self.endpointfilename = endpointfilename
        if pathlinefilename is None:
            pathlinefilename = '{}.{}'.format(model.name, 'mppth')
        self.pathlinefilename = pathlinefilename
        if timeseriesfilename is None:
            timeseriesfilename = '{}.{}'.format(model.name, 'timeseries')
        self.timeseriesfilename = timeseriesfilename
        if tracefilename is None:
            tracefilename = '{}.{}'.format(model.name, 'trace')
        self.tracefilename = tracefilename

        try:
            self.simulationtype = simType[simulationtype.lower()].value
        except:
            self._enum_error('simulationtype', simulationtype, simType)
        try:
            self.trackingdirection = trackDir[trackingdirection.lower()].value
        except:
            self._enum_error('trackingdirection', trackingdirection,
                             trackDir)
        try:
            self.weaksinkoption = weakOpt[weaksinkoption.lower()].value
        except:
            self._enum_error('weaksinkoption', weaksinkoption,
                             weakOpt)
        try:
            self.weaksourceoption = weakOpt[weaksourceoption.lower()].value
        except:
            self._enum_error('weaksourceoption', weaksourceoption,
                             weakOpt)
        try:
            self.budgetoutputoption = \
                budgetOpt[budgetoutputoption.lower()].value
        except:
            self._enum_error('budgetoutputoption', budgetoutputoption,
                             budgetOpt)
        # tracemode
        if traceparticledata is None:
            tracemode = 0
            traceparticlegroup = None
            traceparticleid = None
        else:
            tracemode = 1
            if isinstance(traceparticledata, (list, tuple)):
                if len(traceparticledata) != 2:
                    msg = 'traceparticledata must be a list or tuple ' + \
                          'with 2 items (a integer and an integer). ' + \
                          'Passed item {}.'.format(traceparticledata)
                    raise ValueError(msg)
                try:
                    traceparticlegroup = int(traceparticledata[0])
                except:
                    msg = 'traceparticledata[0] ' + \
                          '({}) '.format(traceparticledata[0]) + \
                          'cannot be converted to a integer.'
                    raise ValueError(msg)
                try:
                    traceparticleid = int(traceparticledata[1])
                except:
                    msg = 'traceparticledata[1] ' + \
                          '({}) '.format(traceparticledata[0]) + \
                          'cannot be converted to a integer.'
                    raise ValueError(msg)
            else:
                msg = 'traceparticledata must be a list or ' + \
                      'tuple with 2 items (a integer and an integer).'
                raise ValueError(msg)

        # set tracemode, traceparticlegroup, and traceparticleid
        self.tracemode = tracemode
        self.traceparticlegroup = traceparticlegroup
        self.traceparticleid = traceparticleid

        if budgetcellnumbers is None:
            BudgetCellCount = 0
        else:
            if isinstance(budgetcellnumbers, int):
                budgetcellnumbers = [budgetcellnumbers]
            budgetcellnumbers = np.array(budgetcellnumbers, dtype=np.int32)
            # validate budget cell numbers
            ncells = np.prod(np.array(self.parent.shape))
            msg = ''
            for cell in budgetcellnumbers:
                if cell < 0 or cell >= ncells:
                    if msg == '':
                        msg = 'Specified cell number(s) exceed the ' + \
                              'number of cells in the model ' + \
                              '(Valid cells = 0-{}). '.format(ncells-1) + \
                              'Invalid cells are: '
                    else:
                        msg += ', '
                    msg += '{}'.format(cell)
            if msg != '':
                raise ValueError(msg)
            # create Util2d object
            BudgetCellCount = budgetcellnumbers.shape[0]
            self.budgetcellnumbers = Util2d(self.parent, (BudgetCellCount,),
                                            np.int32, budgetcellnumbers,
                                            name='budgetcellnumbers',
                                            locat=self.unit_number[0])
        self.BudgetCellCount = BudgetCellCount

        if referencetime is None:
            referencetime = 0.
        if isinstance(referencetime, float):
            referencetime = [referencetime]
        elif isinstance(referencetime, np.ndarray):
            referencetime = referencetime.tolist()
        if len(referencetime) == 1:
            referencetimeOption = 1
            # validate referencetime data
            t = referencetime[0]
            if t < 0. or t > self.parent.time_end:
                msg = 'referencetime must be between 0. and ' + \
                      '{} '.format(self.parent.time_end) + \
                      '(specified value = {}).'.format(t)
                raise ValueError(msg)
        elif len(referencetime) == 3:
            referencetimeOption = 2
            # validate referencetime data
            # StressPeriod
            iper = referencetime[0]
            if iper < 0 or iper >= self.parent.nper:
                msg = 'StressPeriod must be between 0 and ' + \
                      '{} '.format(self.parent.nper - 1) + \
                      '(specified value = {}).'.format(iper)
                raise ValueError(msg)

            # TimeStep
            istp = referencetime[1]
            maxstp = self.parent.nstp[iper] + 1
            if istp < 0 or istp >= maxstp:
                msg = 'TimeStep for StressPeriod {} '.format(iper) + \
                      'must be between 0 and ' + \
                      '{} '.format(maxstp - 1) + \
                      '(specified value = {}).'.format(istp)
                raise ValueError(msg)

            # TimeFraction
            tf = referencetime[2]
            if tf < 0. or tf > 1.:
                msg = 'TimeFraction value must be between 0 and 1 ' + \
                      '(specified value={}).'.format(tf)
                raise ValueError(msg)
        else:
            msg = 'referencetime must be a float (referencetime) or ' + \
                  'a list with one item [referencetime] or three items ' + \
                  '[StressPeriod, TimeStep, TimeFraction]. ' + \
                  '{}'.format(len(referencetime)) + \
                  ' items were passed as referencetime ['
            for i, v in enumerate(referencetime):
                if i > 0:
                    msg += ', '
                msg += '{}'.format(v)
            msg += '].'
            raise ValueError(msg)
        self.referencetimeOption = referencetimeOption
        self.referencetime = referencetime
        # stoptimeoption
        try:
            self.stoptimeoption = \
                stopOpt[stoptimeoption.lower()].value
        except:
            self._enum_error('stoptimeoption', stoptimeoption,
                             stopOpt)
        # StopTime
        if self.stoptimeoption == 3:
            if StopTime is None:
                StopTime = self.parent.time_end
        self.StopTime = StopTime

        # timepointdata
        if timepointdata is not None:
            if not isinstance(timepointdata, list) \
                and not isinstance(timepointdata, tuple):
                msg = 'timepointdata must be a list or tuple'
                raise ValueError(msg)
            else:
                if len(timepointdata) != 2:
                    msg = 'timepointdata must be a list or tuple'
                    raise ValueError(msg)
                else:
                    if isinstance(timepointdata[1], list) \
                        or isinstance(timepointdata[1], tuple):
                        timepointdata[1] = np.array(timepointdata[1])
                    elif isinstance(timepointdata[1], float):
                        timepointdata[1] = np.array([timepointdata[1]])
                    if timepointdata[1].shape[0] == timepointdata[0]:
                        timepointoption = 2
                    elif timepointdata[1].shape[0] > 1:
                        msg = 'The number of TimePoint data ' + \
                              '({}) '.format(timepointdata[1].shape[0]) + \
                              'is not equal to TimePointCount ' + \
                              '({}).'.format(timepointdata[0])
                        raise ValueError(msg)
                    else:
                        timepointoption = 1
        else:
            timepointoption = 0
        self.timepointoption = timepointoption
        self.timepointdata = timepointdata

        # zonedataoption
        try:
            self.zonedataoption = onoffOpt[zonedataoption.lower()].value
        except:
            self._enum_error('zonedataoption', zonedataoption, onoffOpt)
        if self.zonedataoption == 2:
            if stopzone is None:
                stopzone = 0
            if stopzone < 0:
                msg = 'Specified stopzone value ({}) '.format(stopzone) + \
                      'must be greater than 0.'
                raise ValueError(msg)
            self.stopzone = stopzone
            if zones is None:
                msg = "zones must be specified if zonedataoption='on'."
                raise ValueError(msg)
            self.zones = Util3d(model, self.parent.shape, np.int32,
                                zones, name='zones', locat=self.unit_number[0])

        # retardationfactoroption
        try:
            self.retardationfactoroption = \
                onoffOpt[retardationfactoroption.lower()].value
        except:
            self._enum_error('retardationfactoroption',
                             retardationfactoroption, onoffOpt)
        if self.retardationfactoroption == 2:
            if retardation is None:
                msg = "retardation must be specified if " + \
                      "retardationfactoroption='on'."
                raise ValueError(msg)
            self.retardation = Util3d(model, self.parent.shape, np.float32,
                                      retardation, name='retardation',
                                      locat=self.unit_number[0])
        # particle group data
        if particlegroups is None:
            particlegroups = [Particles()]
        elif isinstance(particlegroups, Particles):
            particlegroups = [particlegroups]
        self.particlegroups = particlegroups


        self.parent.add_package(self)

    def _enum_error(self, v, s, e):
        msg = 'Invalid {} ({})'.format(v, s) + \
              '. Valid types are '
        for i, c in enumerate(e):
            if i > 0:
                msg += ', '
            msg += '"{}"'.format(c.name)
        raise ValueError(msg)

    def write_file(self, check=False):
        """
        Write the package file

        Returns
        -------
        None

        """

        f = open(self.fn_path, 'w')
        # item 0
        f.write('{}\n'.format(self.heading))
        # item 1
        f.write('{}\n'.format(self.mp_name_file))
        # item 2
        f.write('{}\n'.format(self.listingfilename))
        # item 3
        f.write('{} {} {} {} {} {}\n'.format(self.simulationtype,
                                             self.trackingdirection,
                                             self.weaksinkoption,
                                             self.weaksourceoption,
                                             self.budgetoutputoption,
                                             self.tracemode))
        # item 4
        f.write('{}\n'.format(self.endpointfilename))
        # item 5
        if self.simulationtype == 2 or self.simulationtype == 4:
            f.write('{}\n'.format(self.pathlinefilename))
        # item 6
        if self.simulationtype == 3 or self.simulationtype == 4:
            f.write('{}\n'.format(self.timeseriesfilename))
        # item 7 and 8
        if self.tracemode == 1:
            f.write('{}\n'.format(self.tracefilename))
            f.write('{} {}\n'.format(self.traceparticlegroup + 1,
                                     self.traceparticleid + 1))
        # item 9
        f.write('{}\n'.format(self.BudgetCellCount))
        # item 10
        if self.BudgetCellCount > 0:
            v = Util2d(self.parent, (self.BudgetCellCount,),
                       np.int32, self.budgetcellnumbers.array+1,
                       name='temp',
                       locat=self.unit_number[0])
            f.write(v.string)

        # item 11
        f.write('{}\n'.format(self.referencetimeOption))
        if self.referencetimeOption == 1:
            # item 12
            f.write('{:g}\n'.format(self.referencetime[0]))
        elif self.referencetimeOption == 2:
            # item 13
            f.write('{:d} {:d} {:g}\n'.format(self.referencetime[0] + 1,
                                              self.referencetime[1] + 1,
                                              self.referencetime[2]))
        # item 14
        f.write('{}\n'.format(self.stoptimeoption))
        if self.stoptimeoption == 3:
            # item 15
            f.write('{:g}\n'.format(self.StopTime))

        # item 16
        if self.simulationtype == 3 or self.simulationtype == 4:
            f.write('{}\n'.format(self.timepointoption))
            if self.timepointoption == 1:
                # item 17
                f.write('{} {}\n'.format(self.timepointdata[0],
                                         self.timepointdata[1][0]))
            elif self.timepointoption == 2:
                # item 18
                f.write('{}\n'.format(self.timepointdata[0]))
                # item 19
                tp = self.timepointdata[1]
                v = Util2d(self.parent, (tp.shape[0],),
                       np.float32, tp,
                       name='temp',
                       locat=self.unit_number[0])
                f.write(v.string)

        # item 20
        f.write('{}\n'.format(self.zonedataoption))
        if self.zonedataoption == 2:
            # item 21
            f.write('{}\n'.format(self.stopzone))
            # item 22
            f.write(self.zones.get_file_entry())

        # item 23
        f.write('{}\n'.format(self.retardationfactoroption))
        if self.retardationfactoroption == 2:
            # item 24
            f.write(self.retardation.get_file_entry())

        # item 25
        f.write('{}\n'.format(len(self.particlegroups)))
        for pg in self.particlegroups:
            pg.write(f, ws=self.parent.model_ws)

        f.close()
