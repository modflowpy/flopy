"""
mpsim module.  Contains the ModpathSim class. Note that the user can access
the ModpathSim class as `flopy.modpath.ModpathSim`.

Additional information for this MODFLOW/MODPATH package can be found at the
`Online MODFLOW Guide
<http://water.usgs.gov/ogw/modflow/MODFLOW-2005-Guide/index.html?dis.htm>`_.

"""
import numpy as np
from ..pakbase import Package
from ..utils import Util2d, Util3d, check
from .mp7particle import LayerRowColumnParticles
from enum import Enum

class simType(Enum):
    """
    Enumeration of different simulation types
    """
    endpoint = 1
    pathline = 2
    timeseries = 3
    combined = 4

class trackDir(Enum):
    """
    Enumeration of different tracking directions
    """
    forward = 1
    backward = 2

class weakOpt(Enum):
    """
    Enumeration of different weak sink and source options
    """
    pass_through = 1
    stop_at = 2

class budgetOpt(Enum):
    """
    Enumeration of different budget output options
    """
    no = 0
    summary = 1
    record_summary = 2

class stopOpt(Enum):
    """
    Enumeration of different stop time options
    """
    total = 1
    extend = 2
    specified = 3

class onoffOpt(Enum):
    """
    Enumeration of on-off options
    """
    off = 1
    on = 2


class Modpath7Sim(Package):
    """
    MODPATH Simulation File Package Class.

    Parameters
    ----------
    model : model object
        The model object (of type :class:`flopy.modpath.mp.Modpath`) to which
        this package will be added.
    extension : string
        Filename extension (default is 'mpsim')


    Attributes
    ----------
    heading : str
        Text string written to top of package input file.

    Methods
    -------

    See Also
    --------

    Notes
    -----

    Examples
    --------

    >>> import flopy
    >>> m = flopy.modpath.Modpath()
    >>> dis = flopy.modpath.ModpathSim(m)

    """

    def __init__(self, model, mp_name_file=None, mp_list_file=None,
                 endpoint_file=None, pathline_file=None,
                 time_series_file=None, trace_file=None,
                 SimulationType='pathline', TrackingDirection='forward',
                 WeakSinkOption='stop_at', WeakSourceOption='stop_at',
                 BudgetOutputOption='no',
                 TraceParticleGroup=None, TraceParticleId=None,
                 BudgetCellNumbers=None, ReferenceTime=None,
                 StopTimeOption='extend', StopTime=None,
                 TimePointData=None,
                 ZoneDataOption='off', StopZone=None, Zones=None,
                 RetardationFactorOption='off', Retardation=None,
                 ParticleGroups=None,
                 extension='mpsim', unitnumber=None):

        if unitnumber is None:
            unitnumber = model.next_unit()


        # Call ancestor's init to set self.parent, extension, name and unit number
        Package.__init__(self, model, extension, 'MPSIM', unitnumber)

        self.heading = '# {} package for'.format(self.name[0]) + \
                       ' {}, '.format(model.version_types[model.version]) + \
                       'generated by Flopy.'

        # set file names
        if mp_name_file is None:
            mp_name_file = '{}.{}'.format(model.name, 'mpnam')
        self.mp_name_file = mp_name_file
        if mp_list_file is None:
            mp_list_file = '{}.{}'.format(model.name, 'mplst')
        self.mp_list_file = mp_list_file
        if endpoint_file is None:
            endpoint_file = '{}.{}'.format(model.name, 'mpend')
        self.endpoint_file = endpoint_file
        if pathline_file is None:
            pathline_file = '{}.{}'.format(model.name, 'mppth')
        self.pathline_file = pathline_file
        if time_series_file is None:
            time_series_file = '{}.{}'.format(model.name, 'timeseries')
        self.time_series_file = time_series_file
        if trace_file is None:
            trace_file = '{}.{}'.format(model.name, 'trace')
        self.trace_file = trace_file

        try:
            self.SimulationType = simType[SimulationType.lower()].value
        except:
            self._enum_error('SimulationType', SimulationType, simType)
        try:
            self.TrackingDirection = trackDir[TrackingDirection.lower()].value
        except:
            self._enum_error('TrackingDirection', TrackingDirection,
                             trackDir)
        try:
            self.WeakSinkOption = weakOpt[WeakSinkOption.lower()].value
        except:
            self._enum_error('WeakSinkOption', WeakSinkOption,
                             weakOpt)
        try:
            self.WeakSourceOption = weakOpt[WeakSourceOption.lower()].value
        except:
            self._enum_error('WeakSourceOption', WeakSourceOption,
                             weakOpt)
        try:
            self.BudgetOutputOption = \
                budgetOpt[BudgetOutputOption.lower()].value
        except:
            self._enum_error('BudgetOutputOption', BudgetOutputOption,
                             budgetOpt)
        # TraceMode
        if TraceParticleGroup is None or TraceParticleId is None:
            TraceMode = 0
        else:
            TraceMode = 1
        self.TraceMode = TraceMode
        self.TraceParticleGroup = TraceParticleGroup
        self.TraceParticleId = TraceParticleId

        if BudgetCellNumbers is None:
            BudgetCellCount = 0
        else:
            if isinstance(BudgetCellNumbers, int):
                BudgetCellNumbers = [BudgetCellNumbers]
            BudgetCellNumbers = np.array(BudgetCellNumbers, dtype=np.int32)
            # validate budget cell numbers
            ncells = np.prod(np.array(self.parent.shape))
            msg = ''
            for cell in BudgetCellNumbers:
                if cell < 0 or cell >= ncells:
                    if msg == '':
                        msg = 'Specified cell number(s) exceed the ' + \
                              'number of cells in the model ' + \
                              '(Valid cells = 0-{}). '.format(ncells-1) + \
                              'Invalid cells are: '
                    else:
                        msg += ', '
                    msg += '{}'.format(cell)
            if msg != '':
                raise ValueError(msg)
            # create Util2d object
            BudgetCellCount = BudgetCellNumbers.shape[0]
            self.BudgetCellNumbers = Util2d(self.parent, (BudgetCellCount,),
                                            np.int32, BudgetCellNumbers,
                                            name='BUDGETCELLNUMBERS',
                                            locat=self.unit_number[0])
        self.BudgetCellCount = BudgetCellCount

        if ReferenceTime is None:
            ReferenceTime = 0.
        if isinstance(ReferenceTime, float):
            ReferenceTime = [ReferenceTime]
        elif isinstance(ReferenceTime, np.ndarray):
            ReferenceTime = ReferenceTime.tolist()
        if len(ReferenceTime) == 1:
            ReferenceTimeOption = 1
            # validate ReferenceTime data
            t = ReferenceTime[0]
            if t < 0. or t > self.parent.time_end:
                msg = 'ReferenceTime must be between 0. and ' + \
                      '{} '.format(self.parent.time_end) + \
                      '(specified value = {}).'.format(t)
                raise ValueError(msg)
        elif len(ReferenceTime) == 3:
            ReferenceTimeOption = 2
            # validate ReferenceTime data
            # StressPeriod
            iper = ReferenceTime[0]
            if iper < 0 or iper >= self.parent.nper:
                msg = 'StressPeriod must be between 0 and ' + \
                      '{} '.format(self.parent.nper - 1) + \
                      '(specified value = {}).'.format(iper)
                raise ValueError(msg)

            # TimeStep
            istp = ReferenceTime[1]
            maxstp = self.parent.nstp[iper] + 1
            if istp < 0 or istp >= maxstp:
                msg = 'TimeStep for StressPeriod {} '.format(iper) + \
                      'must be between 0 and ' + \
                      '{} '.format(maxstp - 1) + \
                      '(specified value = {}).'.format(istp)
                raise ValueError(msg)

            # TimeFraction
            tf = ReferenceTime[2]
            if tf < 0. or tf > 1.:
                msg = 'TimeFraction value must be between 0 and 1 ' + \
                      '(specified value={}).'.format(tf)
                raise ValueError(msg)
        else:
            msg = 'ReferenceTime must be a float (ReferenceTime) or ' + \
                  'a list with one item [ReferenceTime] or three items ' + \
                  '[StressPeriod, TimeStep, TimeFraction]. ' + \
                  '{}'.format(len(ReferenceTime)) + \
                  ' items were passed as ReferenceTime ['
            for i, v in enumerate(ReferenceTime):
                if i > 0:
                    msg += ', '
                msg += '{}'.format(v)
            msg += '].'
            raise ValueError(msg)
        self.ReferenceTimeOption = ReferenceTimeOption
        self.ReferenceTime = ReferenceTime
        # StopTimeOption
        try:
            self.StopTimeOption = \
                stopOpt[StopTimeOption.lower()].value
        except:
            self._enum_error('StopTimeOption', StopTimeOption,
                             stopOpt)
        # StopTime
        if self.StopTimeOption == 3:
            if StopTime is None:
                StopTime = self.parent.time_end
        self.StopTime = StopTime

        # TimePointData
        if TimePointData is not None:
            if not isinstance(TimePointData, list) \
                and not isinstance(TimePointData, tuple):
                msg = 'TimePointData must be a list or tuple'
                raise ValueError(msg)
            else:
                if len(TimePointData) != 2:
                    msg = 'TimePointData must be a list or tuple'
                    raise ValueError(msg)
                else:
                    if isinstance(TimePointData[1], list) \
                        or isinstance(TimePointData[1], tuple):
                        TimePointData[1] = np.array(TimePointData[1])
                    elif isinstance(TimePointData[1], float):
                        TimePointData[1] = np.array([TimePointData[1]])
                    if TimePointData[1].shape[0] == TimePointData[0]:
                        TimePointOption = 2
                    elif TimePointData[1].shape[0] > 1:
                        msg = 'The number of TimePoint data ' + \
                              '({}) '.format(TimePointData[1].shape[0]) + \
                              'is not equal to TimePointCount ' + \
                              '({}).'.format(TimePointData[0])
                        raise ValueError(msg)
                    else:
                        TimePointOption = 1
            self.TimePointOption = TimePointOption
            self.TimePointData = TimePointData

        # ZoneDataOption
        try:
            self.ZoneDataOption = onoffOpt[ZoneDataOption.lower()].value
        except:
            self._enum_error('ZoneDataOption', ZoneDataOption, onoffOpt)
        if self.ZoneDataOption == 2:
            if StopZone is None:
                StopZone = 0
            if StopZone < 0:
                msg = 'Specified StopZone value ({}) '.format(StopZone) + \
                      'must be greater than 0.'
                raise ValueError(msg)
            self.StopZone = StopZone
            if Zones is None:
                msg = "Zones must be specified if ZoneDataOption='on'."
                raise ValueError(msg)
            self.Zones = Util3d(model, self.parent.shape, np.int32,
                                Zones, name='ZONES', locat=self.unit_number[0])

        # RetardationFactorOption
        try:
            self.RetardationFactorOption = \
                onoffOpt[RetardationFactorOption.lower()].value
        except:
            self._enum_error('RetardationFactorOption',
                             RetardationFactorOption, onoffOpt)
        if self.RetardationFactorOption == 2:
            if Retardation is None:
                msg = "Retardation must be specified if " + \
                      "RetardationFactorOption='on'."
                raise ValueError(msg)
            self.Retardation = Util3d(model, self.parent.shape, np.float32,
                                      Retardation, name='RETARDATION',
                                      locat=self.unit_number[0])
        # particle group data
        if ParticleGroups is None:
            ParticleGroups = [LayerRowColumnParticles()]
        self.ParticleGroups = ParticleGroups


        self.parent.add_package(self)

    def _enum_error(self, v, s, e):
        msg = 'Invalid {} ({})'.format(v, s) + \
              '. Valid types are '
        for i, c in enumerate(e):
            if i > 0:
                msg += ', '
            msg += '"{}"'.format(c.name)
        raise ValueError(msg)

    def write_file(self, check=False):
        """
        Write the package file

        Returns
        -------
        None

        """

        f = open(self.fn_path, 'w')
        # item 0
        f.write('{}\n'.format(self.heading))
        # item 1
        f.write('{}\n'.format(self.mp_name_file))
        # item 2
        f.write('{}\n'.format(self.mp_list_file))
        # item 3
        f.write('{} {} {} {} {} {}\n'.format(self.SimulationType,
                                             self.TrackingDirection,
                                             self.WeakSinkOption,
                                             self.WeakSourceOption,
                                             self.BudgetOutputOption,
                                             self.TraceMode))
        # item 4
        f.write('{}\n'.format(self.endpoint_file))
        # item 5
        if self.SimulationType == 2 or self.SimulationType == 4:
            f.write('{}\n'.format(self.pathline_file))
        # item 6
        if self.SimulationType == 3 or self.SimulationType == 4:
            f.write('{}\n'.format(self.time_series_file))
        # item 7 and 8
        if self.TraceMode == 1:
            f.write('{}\n'.format(self.trace_file))
            f.write('{} {}\n'.format(self.TraceParticleGroup,
                                     self.TraceParticleId))
        # item 9
        f.write('{}\n'.format(self.BudgetCellCount))
        # item 10
        if self.BudgetCellCount > 0:
            v = Util2d(self.parent, (self.BudgetCellCount,),
                       np.int32, self.BudgetCellNumbers.array+1,
                       name='temp',
                       locat=self.unit_number[0])
            f.write(v.string)

        # item 11
        f.write('{}\n'.format(self.ReferenceTimeOption))
        if self.ReferenceTimeOption == 1:
            # item 12
            f.write('{:g}\n'.format(self.ReferenceTime[0]))
        elif self.ReferenceTimeOption == 2:
            # item 13
            f.write('{:d} {:d} {:g}\n'.format(self.ReferenceTime[0] + 1,
                                              self.ReferenceTime[1] + 1,
                                              self.ReferenceTime[2]))
        # item 14
        f.write('{}\n'.format(self.StopTimeOption))
        if self.StopTimeOption == 3:
            # item 15
            f.write('{:g}\n'.format(self.StopTime))

        # item 16
        if self.SimulationType == 3 or self.SimulationType == 4:
            f.write('{}\n'.format(self.TimePointOption))
            if self.TimePointOption == 1:
                # item 17
                f.write('{} {}\n'.format(self.TimePointData[0],
                                         self.TimePointData[1][0]))
            elif self.TimePointOption == 2:
                # item 18
                f.write('{}\n'.format(self.TimePointData[0]))
                # item 19
                tp = self.TimePointData[1]
                v = Util2d(self.parent, (tp.shape[0],),
                       np.float32, tp,
                       name='temp',
                       locat=self.unit_number[0])
                f.write(v.string)

        # item 20
        f.write('{}\n'.format(self.ZoneDataOption))
        if self.ZoneDataOption == 2:
            # item 21
            f.write('{}\n'.format(self.StopZone))
            # item 22
            f.write(self.Zones.get_file_entry())

        # item 23
        f.write('{}\n'.format(self.RetardationFactorOption))
        if self.RetardationFactorOption == 2:
            # item 24
            f.write(self.Retardation.get_file_entry())

        # item 25
        f.write('{}\n'.format(len(self.ParticleGroups)))
        for pg in self.ParticleGroups:
            pg.write(f, ws=self.parent.model_ws)

        f.close()
